#!/usr/bin/env python3

import json
import psycopg2
import pymysql
import sqlite3
import sys

def make_dict(keys, values):
    if len(keys) != len(values):
        raise Exception("Cannot make_dict: {}".format({"keys": keys, "values": values}))
    return { keys[i]: values[i] for i in range(len(keys)) }

def make_table(data, columns):
    return [make_dict(columns, row) for row in data]

class DB:
    def read_table(self, table_name):
        columns = self.column_names(table_name)

        data = self.query("select * from {};".format(table_name))
        return make_table(data, columns)

    def read_tables(self):
        return { name: self.read_table(name) for name in self.table_names() }

    def as_json(self):
        print(json.dumps(self.read_tables()))

    def get_type(command):
        TYPES = [SQLITE3, PSQL, MYSQL]
        possible_t = [t for t in TYPES if t.DB_TYPE_S == command]
        if possible_t == []:
            raise Exception("No type found for: {}".format(command))
        elif len(possible_t) > 1:
            raise Exception("More than one type found for: {}".format(command))

        return possible_t[0]


class SQLITE3(DB):
    DB_TYPE_S = "sqlite3"
    def __init__(self, filename):
        self.c = sqlite3.connect(filename).cursor()

    def query(self, query_string):
        data = list(self.c.execute(query_string))
        return data

    def column_names(self, table_name):
        columns = self.query("pragma table_info({});".format(table_name))
        return [column[1] for column in columns]

    def table_names(self):
        master_table = self.read_table("sqlite_master")
        return [e["name"] for e in master_table if e["type"] == "table"]

class PSQL(DB):
    DB_TYPE_S = "psql"

    def __init__(self, user, password, host, port, database):
        self.connection = psycopg2.connect(
                user = user,
                password = password,
                host = host,
                port = port,
                database = database)

    def query(self, query_string):
        cursor = self.connection.cursor()
        cursor.execute(query_string)
        return [list(r) for r in cursor.fetchall()]

    def column_names(self, table_name):
        return self.query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))[0]

    def table_names(self):
        return [t[0] for t in self.query("select table_name from information_schema.tables where table_schema = 'public';")]

class MYSQL(DB):
    DB_TYPE_S = "mysql"

    def __init__(self, user, password, host, database):
        self.database = database
        self.connection = pymysql.connect(
                host,
                user,
                password,
                database)

    def query(self, query_string):
        cursor = self.connection.cursor()
        cursor.execute(query_string)
        data = [list(r) for r in cursor.fetchall()]
        return data

    def column_names(self, table_name):
        return self.query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))[0]

    def table_names(self):
        return [t[0] for t in self.query("select table_name from information_schema.tables where table_schema = '{}';".format(self.database))]

def read(db_type_s, credentials):
    return DB.get_type(db_type_s)(*credentials).as_json()

def help_message():
    print("TODO: Implement help message")
    return None

def main():
    if len(sys.argv) >= 4 and sys.argv[1] == "read":
        return read(sys.argv[2], sys.argv[3:])
    else:
        return help_message()

if __name__ == "__main__":
    main()
