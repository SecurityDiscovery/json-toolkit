#!/usr/bin/env python3

import json
import psycopg2
import pymysql
import sqlite3
import sys


def make_dict(keys, values):
    if len(keys) != len(values):
        raise Exception("Cannot make_dict: {}".format(
            {"keys": keys, "values": values}))
    return {keys[i]: values[i] for i in range(len(keys))}


def make_table(data, columns):
    return [make_dict(columns, row) for row in data]


class DB:
    def query(self, query_string):
        def cursor_has_results(cursor):
            # DB API 2.0 states that when the cursor does not return results
            # exactly when cursor.description is None.
            return bool(cursor.description)

        cursor = self.connection.cursor()
        cursor.execute(query_string)
        self.connection.commit()

        if cursor_has_results(cursor):
            return [list(r) for r in cursor.fetchall()]
        # If the cursor does not have results, assume it returns a row count
        return cursor.rowcount

        return data

    def read_table(self, table_name):
        columns = self.column_names(table_name)

        data = self.query("select * from {};".format(table_name))
        return make_table(data, columns)

    def read_tables(self):
        return {name: self.read_table(name) for name in self.table_names()}

    def as_json(self):
        print(json.dumps(self.read_tables()))

    def validate_writes(self, writes):
        return []

    def execute_writes(self, writes):
        write_errors = self.validate_writes(writes)

        if write_errors != []:
            raise Exception("Write errors:{}".format(json.dumps(writes)))

        for write in writes:
            if write["type"] == "insert":
                value_string = ",".join([str(v) for v in write["values"]])
                self.query("insert into {} values({})".format(
                    write["table"], value_string))
            elif write["type"] == "create table":
                value_strings = ["{} {}".format(
                    field["name"], field["type"]) for field in write["fields"]]
                value_string = ",".join(value_strings)
                self.query("create table {} ({})".format(
                    write["name"], value_string))
            else:
                raise Exception("Bad write: {}".format(json.dumps(write)))

    def get_type(command):
        TYPES = [SQLITE3, PSQL, MYSQL]
        possible_t = [t for t in TYPES if t.__name__ == command.upper()]
        if possible_t == []:
            raise Exception("No type found for: {}".format(command))
        elif len(possible_t) > 1:
            raise Exception("More than one type found for: {}".format(command))

        return possible_t[0]


class SQLITE3(DB):
    def __init__(self, filename):
        self.connection = sqlite3.connect(filename)

    def column_names(self, table_name):
        columns = self.query("pragma table_info({});".format(table_name))
        return [column[1] for column in columns]

    def table_names(self):
        master_table = self.read_table("sqlite_master")
        return [e["name"] for e in master_table if e["type"] == "table"]


class PSQL(DB):
    def __init__(self, user, password, host, port, database):
        self.connection = psycopg2.connect(
            user=user,
            password=password,
            host=host,
            port=port,
            database=database)

    def column_names(self, table_name):
        names = self.query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))
        return [n[0] for n in names]

    def table_names(self):
        return [t[0] for t in self.query("select table_name from information_schema.tables where table_schema = 'public';")]


class MYSQL(DB):
    def __init__(self, user, password, host, database):
        self.database = database
        self.connection = pymysql.connect(
            host,
            user,
            password,
            database)

    def column_names(self, table_name):
        return self.query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))[0]

    def table_names(self):
        return [t[0] for t in self.query("select table_name from information_schema.tables where table_schema = '{}';".format(self.database))]


def read(db_type_s, credentials):
    return DB.get_type(db_type_s)(*credentials).as_json()


def write(data):
    return DB.get_type(data["db_type"])(*data["credentials"]).execute_writes(data["writes"])


def help_message():
    print("TODO: Implement help message")
    return None


def main():
    if len(sys.argv) >= 4 and sys.argv[1] == "read":
        return read(sys.argv[2], sys.argv[3:])
    if len(sys.argv) == 2 and sys.argv[1] == "write":
        return write(json.load(sys.stdin))
    else:
        return help_message()


if __name__ == "__main__":
    main()
