#!/usr/bin/env python3

import decimal
import json
import psycopg2
import pymysql
import sqlite3
import sys

def jsonable(o):
    if type(o) in [str, int, float, bool, type(None)]:
        return o
    elif type(o) in [list]:
        return [jsonable(e) for e in o]
    elif type(o) in [dict]:
        return {str(k): jsonable(o[k]) for k in o}
    elif type(o) in [decimal.Decimal]:
        return float(o)
    else:
        raise Exception("Cannot make object jsonable:{}:{}".format(str(type(o)),str(o)))



def make_table(data, columns):
    def make_dict(keys, values):
        if len(keys) != len(values):
            raise Exception("Cannot make_dict: {}".format(
                {"keys": keys, "values": values}))
        return {keys[i]: values[i] for i in range(len(keys))}


    return [make_dict(columns, row) for row in data]


class DB:
    def execute_query(self, query_string):
        def cursor_has_results(cursor):
            # DB API 2.0 states that when the cursor does not return results
            # exactly when cursor.description is None.
            return bool(cursor.description)

        cursor = self.connection.cursor()
        cursor.execute(query_string)
        self.connection.commit()

        if cursor_has_results(cursor):
            return [list(r) for r in cursor.fetchall()]
        # If the cursor does not have results, assume it returns a row count
        return cursor.rowcount

    def read_table(self, table_name):
        columns = self.column_names(table_name)

        data = self.execute_query("select * from {};".format(table_name))
        return make_table(data, columns)

    def read_tables(self):
        return {name: self.read_table(name) for name in self.table_names()}

    def read(self):
        return jsonable(self.read_tables())

    def get_type(command):
        TYPES = [SQLITE3, PSQL, MYSQL]
        possible_t = [t for t in TYPES if t.__name__ == command.upper()]
        if possible_t == []:
            raise Exception("No type found for: {}".format(command))
        elif len(possible_t) > 1:
            raise Exception("More than one type found for: {}".format(command))

        return possible_t[0]


class SQLITE3(DB):
    def __init__(self, filename):
        self.connection = sqlite3.connect(filename)

    def column_names(self, table_name):
        columns = self.execute_query("pragma table_info({});".format(table_name))
        return [column[1] for column in columns]

    def table_names(self):
        master_table = self.read_table("sqlite_master")
        return [e["name"] for e in master_table if e["type"] == "table"]


class PSQL(DB):
    def __init__(self, user, password, host, port, database):
        self.connection = psycopg2.connect(
            user=user,
            password=password,
            host=host,
            port=port,
            database=database)

    def column_names(self, table_name):
        names = self.execute_query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))
        return [n[0] for n in names]

    def table_names(self):
        return [t[0] for t in self.execute_query("select table_name from information_schema.tables where table_schema = 'public';")]


class MYSQL(DB):
    def __init__(self, user, password, host, database):
        self.database = database
        self.connection = pymysql.connect(
            host,
            user,
            password,
            database)

    def column_names(self, table_name):
        return self.execute_query("select column_name from information_schema.columns where table_name = '{}';".format(table_name))[0]

    def table_names(self):
        return [t[0] for t in self.execute_query("select table_name from information_schema.tables where table_schema = '{}';".format(self.database))]


def help_message():
    return \
"""
Usage: json-sql COMMAND DB_TYPE CREDENTIALS

Overview:
    json-sql makes it easy to read/write data to/from a sql database in the command line. It intentionally lacks many features that can be easily achieved with other programs. For example, although , as the output of json-sql can be piped into another program to 

COMMAND:
    read - reads the entire database and dumps it as json on stdout.

    query - execute queries passed in as a json array on stdin and returns the results as a json array on stdout. For queries with results, the output is the result. For queries without result, the output is the number of rows affected.

DB_TYPE:
    psql - PostgreSQL
    mysql - MySQL
    sqlite3 - Sqlite3

CREDENTIALS:
    The credentials depends on the db type:
        psql - user password host port database
        mysql - user password host port database
        sqlite3 - filename

Example usages:
    Read from a psql DB:
        json-sql read psql user password localhost 5432 db

    Read from a mysql DB:
        json-sql read mysql user password localhost 3306 db

    Read from a sqlite3 DB:
        json-sql read sqlite3 db.sqlite

    Insert data into a mysql DB:
        echo ["insert into table (a,b,c) values(1, 2, 3);"] | json-sql query mysql user password localhost 3306 db

Example advanced usage with other programs:
    Read a specific table from a psql DB:
        json-sql read psql user password localhost 5432 db | jq '.table'

    Delete a list of ids from a psql DB:
        echo '[1, 2, 3, 4]' | jq "[\"delete from json_nosql_db where id in (\" + join(\",\") + \");\"]" | json-sql query psql user password localhost 5432 db"""


def main():
    if len(sys.argv) < 4:
        print(help_message())
        return

    method = sys.argv[1]
    db_type_s = sys.argv[2]
    # Credential length varies depending on db type
    credentials = sys.argv[3:]
    db = DB.get_type(db_type_s)(*credentials)

    if method == "read":
        print(json.dumps(db.read()))
    elif method == "query":
        queries = json.load(sys.stdin)
        print(json.dumps([db.execute_query(query) for query in queries]))
    else:
        print(help_message())
    return


if __name__ == "__main__":
    main()
